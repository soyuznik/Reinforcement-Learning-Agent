<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diep.io 5x Parallel DQN Training</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #chartsContainer {
            display: flex;
            justify-content: space-around;
            width: 95%;
            margin-bottom: 20px;
        }
        .chart-container {
            width: 32%;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #gamesContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
        }
        .gameInstance {
            position: relative;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }
        .gameCanvas {
            background-color: white;
            display: block;
        }
        .stats {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            display: grid;
            grid-template-columns: auto auto;
            gap: 2px 8px;
            pointer-events: none;
        }
        .stat-label {
            font-weight: bold;
        }
        .statusMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            z-index: 20;
            display: none;
        }
        #controls {
            margin-bottom: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #toggleButton {
            padding: 10px 15px;
            background-color: #808080;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #toggleButton:hover {
            background-color: #707070;
        }
    </style>
</head>
<body>
    <div id="chartsContainer">
        <div class="chart-container">
            <canvas id="scoreChart"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="rewardChart"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="epsilonChart"></canvas>
        </div>
    </div>

    <div id="controls">
        <button id="toggleButton">TOGGLE AI GRID</button>
    </div>

    <div id="gamesContainer"></div>

    <script>
        // Game constants
        const NUM_GAMES = 6;
        const WIDTH = 700; // Canvas size to fit multiple games
        const HEIGHT = 800;
        const GRID_SIZE = 20; // Reverted to original
        const TANK_SIZE = 20;
        const BULLET_SIZE = 4;
        const MAX_SHAPES = 15;
        const MAX_ENEMIES = 1;
        const FPS = 60;
        const SHOOT_COOLDOWN = 20;
        const BULLET_SPEED = 2;
        const WORLD_SIZE = 5000; // Reverted to original

        // Colors
        const WHITE = '#FFFFFF';
        const RED = '#FF0000';
        const BLUE = '#0000FF';
        const YELLOW = '#FFFF00';
        const GRAY = '#808080';
        const LIGHT_GRAY = '#f0f0f0';

        const SHAPE_TYPES = {
            'square': { color: YELLOW, points: 10, size: 12 },
            'triangle': { color: RED, points: 20, size: 14 },
            'pentagon': { color: BLUE, points: 30, size: 20 },
        };

        const GRID_ROWS = Math.floor(HEIGHT / GRID_SIZE);
        const GRID_COLS = Math.floor(WIDTH / GRID_SIZE);
        const MOVEMENT_ACTIONS = 4; // Up, Down, Left, Right
        const SHOOTING_ACTIONS = GRID_ROWS * GRID_COLS;
        const ACTION_SIZE = MOVEMENT_ACTIONS + SHOOTING_ACTIONS;

        class DiepIOEnv {
            constructor(id, canvas) {
                this.id = id;
                this.canvas = canvas;
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = WIDTH;
                this.canvas.height = HEIGHT;
                
                this.statsContainer = document.querySelector(`#game-${id} .stats`);
                this.statusMessage = document.querySelector(`#game-${id} .statusMessage`);

                this.ai_grid_visible = false;
                this.reset();
            }

            reset() {
                this.setRandomPosition();
                this.score = 0;
                if (this.deaths === undefined) {
                    this.deaths = 0;
                }
                this.shapes = [];
                this.enemies = [];
                this.bullets = [];
                this.enemy_bullets = [];
                this.shoot_timer = 0;
                this.shoot_angle = 0;
                this.isRespawning = false;
                this.respawnTimer = 0;

                this.generateInitialShapes();
                this.generateInitialEnemies();

                return this.get_state();
            }

            setRandomPosition() {
                this.player_world_x = Math.random() * WORLD_SIZE - WORLD_SIZE / 2;
                this.player_world_y = Math.random() * WORLD_SIZE - WORLD_SIZE / 2;
            }

            generateInitialShapes() {
                for (let i = 0; i < MAX_SHAPES; i++) {
                    this.generateShape(100, 400);
                }
            }

            generateInitialEnemies() {
                for (let i = 0; i < MAX_ENEMIES; i++) {
                    this.generateEnemy(200, 500);
                }
            }
            
            generateShape(minDistance = 100, maxDistance = 500) {
                 if (this.shapes.length >= MAX_SHAPES) return;
                let angle = Math.random() * Math.PI * 2;
                let distance = minDistance + Math.random() * (maxDistance - minDistance);
                let x = this.player_world_x + Math.cos(angle) * distance;
                let y = this.player_world_y + Math.sin(angle) * distance;
                this.shapes.push({
                    type: Object.keys(SHAPE_TYPES)[Math.floor(Math.random() * Object.keys(SHAPE_TYPES).length)],
                    pos: [x, y]
                });
            }

            generateEnemy(minDistance = 200, maxDistance = 600) {
                if (this.enemies.length >= MAX_ENEMIES) return;
                let angle = Math.random() * Math.PI * 2;
                let distance = minDistance + Math.random() * (maxDistance - minDistance);
                let x = this.player_world_x + Math.cos(angle) * distance;
                let y = this.player_world_y + Math.sin(angle) * distance;
                this.enemies.push({ pos: [x, y], shoot_timer: Math.random() * 80 });
            }

            respawnPlayer() {
                this.isRespawning = true;
                this.respawnTimer = 6; // 0.1 second at 60fps
                this.deaths++;
                this.score = 0; // Reset score on death
                this.statusMessage.textContent = "RESPAWNING";
                this.statusMessage.style.display = 'block';
                
                this.setRandomPosition();
                this.bullets = [];
                this.enemy_bullets = [];
                this.shapes = [];
                this.enemies = [];
                this.generateInitialShapes();
                this.generateInitialEnemies();
            }

            get_state() {
                const grid = Array(GRID_ROWS).fill().map(() => Array(GRID_COLS).fill(0));
                const offsetX = this.player_world_x - WIDTH / 2;
                const offsetY = this.player_world_y - HEIGHT / 2;

                const processEntities = (entities, value) => {
                    entities.forEach(entity => {
                        const pos = Array.isArray(entity) ? entity : entity.pos;
                        const viewport_x = pos[0] - offsetX;
                        const viewport_y = pos[1] - offsetY;
                        if (viewport_x >= 0 && viewport_x < WIDTH && viewport_y >= 0 && viewport_y < HEIGHT) {
                            const grid_x = Math.floor(viewport_x / GRID_SIZE);
                            const grid_y = Math.floor(viewport_y / GRID_SIZE);
                            if(grid_y >= 0 && grid_y < GRID_ROWS && grid_x >=0 && grid_x < GRID_COLS) {
                                grid[grid_y][grid_x] = value;
                            }
                        }
                    });
                };

                processEntities(this.shapes, 1);
                processEntities(this.enemies, 2);
                processEntities(this.enemy_bullets, 3);
                
                return grid.flat();
            }

            step(action) {
                if (this.isRespawning) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) {
                        this.isRespawning = false;
                        this.statusMessage.style.display = 'none';
                    }
                    return [this.get_state(), 0, false];
                }

                let reward = 0; 
                let done = false;
                const speed = 5;

                if (action < MOVEMENT_ACTIONS) {
                    reward += 0.3; 
                    switch (action) {
                        case 0: this.player_world_y -= speed; break;
                        case 1: this.player_world_y += speed; break;
                        case 2: this.player_world_x -= speed; break;
                        case 3: this.player_world_x += speed; break;
                    }
                } else { 
                    if (this.shoot_timer === 0) {
                        reward += 0.2;
                        const shoot_action_index = action - MOVEMENT_ACTIONS;
                        const target_row = Math.floor(shoot_action_index / GRID_COLS);
                        const target_col = shoot_action_index % GRID_COLS;

                        const viewport_x = (target_col + 0.5) * GRID_SIZE;
                        const viewport_y = (target_row + 0.5) * GRID_SIZE;
                        const world_x = viewport_x + (this.player_world_x - WIDTH / 2);
                        const world_y = viewport_y + (this.player_world_y - HEIGHT / 2);

                        const dx = world_x - this.player_world_x;
                        const dy = world_y - this.player_world_y;
                        this.shoot_angle = Math.atan2(dy, dx);

                        this.bullets.push([
                            this.player_world_x, this.player_world_y,
                            Math.cos(this.shoot_angle) * 7, Math.sin(this.shoot_angle) * 7
                        ]);
                        this.shoot_timer = SHOOT_COOLDOWN;
                    }
                }
                
                let hit_reward = this.updateBullets();
                reward += hit_reward;
                this.updateEnemies();
                const died = this.updateEnemyBullets();
                if (died) {
                    reward = -100;
                    done = true;
                }

                if (this.shoot_timer > 0) this.shoot_timer--;
                
                this.ensureVisibleObjects();

                return [this.get_state(), reward, done];
            }
            
            updateBullets() {
                let reward = 0;
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet[0] += bullet[2] * BULLET_SPEED;
                    bullet[1] += bullet[3] * BULLET_SPEED;

                    if (Math.hypot(bullet[0] - this.player_world_x, bullet[1] - this.player_world_y) > 1000) {
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    let hit = false;
                    for (let j = this.shapes.length - 1; j >= 0; j--) {
                        const shape = this.shapes[j];
                        const shapeInfo = SHAPE_TYPES[shape.type];
                        if (Math.hypot(bullet[0] - shape.pos[0], bullet[1] - shape.pos[1]) < shapeInfo.size + BULLET_SIZE) {
                            this.score += shapeInfo.points;
                            reward += shapeInfo.points;
                            this.shapes.splice(j, 1);
                            this.bullets.splice(i, 1);
                            hit = true;
                            break;
                        }
                    }
                    if (hit) continue;

                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        if (Math.hypot(bullet[0] - enemy.pos[0], bullet[1] - enemy.pos[1]) < TANK_SIZE + BULLET_SIZE) {
                            this.score += 50;
                            reward += 50;
                            this.enemies.splice(j, 1);
                            this.bullets.splice(i, 1);
                            hit = true;
                            break;
                        }
                    }
                }
                return reward;
            }

            updateEnemies() {
                this.enemies.forEach(enemy => {
                    const dx = this.player_world_x - enemy.pos[0];
                    const dy = this.player_world_y - enemy.pos[1];
                    const dist = Math.hypot(dx, dy);
                    if (dist > 0) {
                        enemy.pos[0] += (dx / dist) * 1.5;
                        enemy.pos[1] += (dy / dist) * 1.5;
                    }
                    if (enemy.shoot_timer > 0) {
                        enemy.shoot_timer--;
                    } else if (dist < 400) {
                        const angle = Math.atan2(dy, dx);
                        this.enemy_bullets.push([
                            enemy.pos[0], enemy.pos[1],
                            Math.cos(angle) * 5, Math.sin(angle) * 5
                        ]);
                        enemy.shoot_timer = 90;
                    }
                });
            }

            updateEnemyBullets() {
                 for (let i = this.enemy_bullets.length - 1; i >= 0; i--) {
                    const bullet = this.enemy_bullets[i];
                    bullet[0] += bullet[2] * BULLET_SPEED;
                    bullet[1] += bullet[3] * BULLET_SPEED;

                    if (Math.hypot(bullet[0] - this.player_world_x, bullet[1] - this.player_world_y) > 1000) {
                        this.enemy_bullets.splice(i, 1);
                        continue;
                    }

                    if (!this.isRespawning && Math.hypot(bullet[0] - this.player_world_x, bullet[1] - this.player_world_y) < TANK_SIZE + BULLET_SIZE) {
                        this.enemy_bullets.splice(i, 1);
                        return true;
                    }
                }
                return false;
            }

            ensureVisibleObjects() {
                if (this.shapes.length < MAX_SHAPES / 2) {
                    this.generateShape(100, 400);
                }
                if (this.enemies.length < MAX_ENEMIES) {
                    this.generateEnemy(200, 500);
                }
            }

            render() {
                this.ctx.fillStyle = WHITE;
                this.ctx.fillRect(0, 0, WIDTH, HEIGHT);

                const offsetX = this.player_world_x - WIDTH / 2;
                const offsetY = this.player_world_y - HEIGHT / 2;
                
                this.ctx.strokeStyle = LIGHT_GRAY;
                this.ctx.lineWidth = 1;
                for (let x = -offsetX % GRID_SIZE; x <= WIDTH; x += GRID_SIZE) {
                    this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, HEIGHT); this.ctx.stroke();
                }
                for (let y = -offsetY % GRID_SIZE; y <= HEIGHT; y += GRID_SIZE) {
                    this.ctx.beginPath(); this.ctx.moveTo(0, y); this.ctx.lineTo(WIDTH, y); this.ctx.stroke();
                }

                const drawEntity = (entity, drawFunc) => {
                    const pos = Array.isArray(entity) ? entity : entity.pos;
                    const viewportX = pos[0] - offsetX;
                    const viewportY = pos[1] - offsetY;
                    if (viewportX > -50 && viewportX < WIDTH + 50 && viewportY > -50 && viewportY < HEIGHT + 50) {
                        drawFunc(viewportX, viewportY, entity);
                    }
                };

                this.shapes.forEach(shape => drawEntity(shape, (vx, vy) => {
                    const shapeInfo = SHAPE_TYPES[shape.type];
                    this.ctx.fillStyle = shapeInfo.color;
                    this.ctx.strokeStyle = '#555555';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    switch (shape.type) {
                        case 'square':
                            this.ctx.rect(vx - shapeInfo.size, vy - shapeInfo.size, shapeInfo.size * 2, shapeInfo.size * 2);
                            break;
                        case 'triangle':
                            this.ctx.moveTo(vx, vy - shapeInfo.size);
                            this.ctx.lineTo(vx - shapeInfo.size, vy + shapeInfo.size);
                            this.ctx.lineTo(vx + shapeInfo.size, vy + shapeInfo.size);
                            this.ctx.closePath();
                            break;
                        case 'pentagon':
                             for (let i = 0; i < 5; i++) {
                                const angle = i * 2 * Math.PI / 5 - Math.PI / 2;
                                const x = vx + shapeInfo.size * Math.cos(angle);
                                const y = vy + shapeInfo.size * Math.sin(angle);
                                if (i === 0) this.ctx.moveTo(x, y);
                                else this.ctx.lineTo(x, y);
                            }
                            this.ctx.closePath();
                            break;
                    }
                    this.ctx.fill();
                    this.ctx.stroke();
                }));

                this.enemies.forEach(enemy => drawEntity(enemy, (vx, vy) => {
                    this.ctx.fillStyle = RED;
                    this.ctx.strokeStyle = '#555555';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(vx, vy, TANK_SIZE, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();

                    const angle = Math.atan2((this.player_world_y - offsetY) - vy, (this.player_world_x - offsetX) - vx);
                    this.ctx.save();
                    this.ctx.translate(vx, vy);
                    this.ctx.rotate(angle);
                    this.ctx.fillStyle = GRAY;
                    this.ctx.fillRect(0, -5, 30, 10);
                    this.ctx.strokeRect(0, -5, 30, 10);
                    this.ctx.restore();
                }));

                this.bullets.forEach(bullet => drawEntity(bullet, (vx, vy) => {
                    this.ctx.fillStyle = BLUE;
                    this.ctx.beginPath();
                    this.ctx.arc(vx, vy, BULLET_SIZE, 0, 2 * Math.PI);
                    this.ctx.fill();
                }));
                
                this.enemy_bullets.forEach(bullet => drawEntity(bullet, (vx, vy) => {
                    this.ctx.fillStyle = RED;
                    this.ctx.beginPath();
                    this.ctx.arc(vx, vy, BULLET_SIZE, 0, 2 * Math.PI);
                    this.ctx.fill();
                }));

                if (!this.isRespawning) {
                    const playerX = WIDTH / 2;
                    const playerY = HEIGHT / 2;
                    this.ctx.fillStyle = BLUE;
                    this.ctx.strokeStyle = '#555555';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(playerX, playerY, TANK_SIZE, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    this.ctx.save();
                    this.ctx.translate(playerX, playerY);
                    this.ctx.rotate(this.shoot_angle);
                    this.ctx.fillStyle = GRAY;
                    this.ctx.fillRect(0, -5, 30, 10);
                    this.ctx.strokeRect(0, -5, 30, 10);
                    this.ctx.restore();
                }

                // AI Grid drawing logic - REVERTED TO ORIGINAL IMPLEMENTATION
                if (this.ai_grid_visible) {
                    for (let y = 0; y < GRID_ROWS; y++) {
                        for (let x = 0; x < GRID_COLS; x++) {
                            let color = null;
                            const checkCell = (entities, entityColor) => {
                                for (const entity of entities) {
                                    const pos = Array.isArray(entity) ? entity : entity.pos;
                                    const viewport_x = pos[0] - offsetX;
                                    const viewport_y = pos[1] - offsetY;
                                    if (viewport_x >= 0 && viewport_x < WIDTH && viewport_y >= 0 && viewport_y < HEIGHT) {
                                        const grid_x = Math.floor(viewport_x / GRID_SIZE);
                                        const grid_y = Math.floor(viewport_y / GRID_SIZE);
                                        if (grid_x === x && grid_y === y) {
                                            color = entityColor;
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            }

                            if (checkCell(this.shapes, 'rgba(0, 255, 0, 0.5)')) {
                                this.ctx.fillStyle = color;
                                this.ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            } else if (checkCell(this.enemies, 'rgba(255, 0, 0, 0.5)')) {
                                this.ctx.fillStyle = color;
                                this.ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            } else if (checkCell(this.enemy_bullets, 'rgba(255, 165, 0, 0.5)')) {
                                this.ctx.fillStyle = color;
                                this.ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            }
                        }
                    }
                }

                this.statsContainer.querySelector('.score').textContent = this.score;
                this.statsContainer.querySelector('.deaths').textContent = this.deaths;
            }
        }

        class DQN {
            constructor(inputSize, outputSize) {
                this.model = tf.sequential();
                this.model.add(tf.layers.dense({ units: 256, activation: 'relu', inputShape: [inputSize] }));
                this.model.add(tf.layers.dense({ units: 256, activation: 'relu' }));
                this.model.add(tf.layers.dense({ units: outputSize, activation: 'linear' }));
                this.model.compile({ optimizer: tf.train.adam(0.001), loss: 'meanSquaredError' });
            }

            predict(state) {
                return tf.tidy(() => this.model.predict(tf.tensor2d([state])).dataSync());
            }

            async train(states, targets) {
                const xs = tf.tensor2d(states);
                const ys = tf.tensor2d(targets);
                await this.model.fit(xs, ys, { epochs: 1, batchSize: 32, verbose: 0 });
                xs.dispose();
                ys.dispose();
            }
        }

        class DQNAgent {
            constructor(stateSize, actionSize) {
                this.stateSize = stateSize;
                this.actionSize = actionSize;
                this.memory = [];
                this.gamma = 0.99;
                this.epsilon = 1.0;
                this.epsilon_min = 0.1;
                this.epsilon_decay = 0.9995;
                this.model = new DQN(stateSize, actionSize);
                this.target_model = new DQN(stateSize, actionSize);
                this.update_target_model();
            }

            update_target_model() {
                this.target_model.model.setWeights(this.model.model.getWeights());
            }
            
            decay_epsilon() {
                 if (this.epsilon > this.epsilon_min) {
                    this.epsilon *= this.epsilon_decay;
                }
            }

            remember(state, action, reward, next_state, done) {
                this.memory.push({ state, action, reward, next_state, done });
                if (this.memory.length > 50000) {
                    this.memory.shift();
                }
            }

            act(state) {
                if (Math.random() <= this.epsilon) {
                    return Math.floor(Math.random() * this.actionSize);
                }
                const q_values = this.model.predict(state);
                return q_values.indexOf(Math.max(...q_values));
            }

            async replay(batch_size) {
                if (this.memory.length < batch_size) return;

                const minibatch = [];
                for (let i = 0; i < batch_size; i++) {
                    minibatch.push(this.memory[Math.floor(Math.random() * this.memory.length)]);
                }

                const states = minibatch.map(mem => mem.state);
                const next_states = minibatch.map(mem => mem.next_state);

                const current_q_values_batch = tf.tidy(() => this.model.model.predict(tf.tensor2d(states)));
                const next_q_values_batch = tf.tidy(() => this.target_model.model.predict(tf.tensor2d(next_states)));
                
                const current_q_values_data = await current_q_values_batch.array();
                const next_q_values_data = await next_q_values_batch.array();

                tf.dispose([current_q_values_batch, next_q_values_batch]);
                
                const targets = [];
                for (let i = 0; i < minibatch.length; i++) {
                    const { action, reward, done } = minibatch[i];
                    let target = reward;
                    if (!done) {
                        target += this.gamma * Math.max(...next_q_values_data[i]);
                    }
                    let current_q = current_q_values_data[i];
                    current_q[action] = target;
                    targets.push(current_q);
                }

                await this.model.train(states, targets);
            }
        }

        function createChart(ctx, label) {
            return new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [{ label, data: [], borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 2, fill: false, tension: 0.1, pointRadius: 0 }] },
                options: {
                    scales: { y: { beginAtZero: false } },
                    animation: { duration: 200 }
                }
            });
        }
        
        async function main() {
            const gamesContainer = document.getElementById('gamesContainer');
            for (let i = 0; i < NUM_GAMES; i++) {
                const gameDiv = document.createElement('div');
                gameDiv.className = 'gameInstance';
                gameDiv.id = `game-${i}`;
                gameDiv.innerHTML = `
                    <canvas class="gameCanvas"></canvas>
                    <div class="stats">
                        <div class="stat-label">Score:</div><div class="score">0</div>
                        <div class="stat-label">Deaths:</div><div class="deaths">0</div>
                    </div>
                    <div class="statusMessage"></div>
                `;
                gamesContainer.appendChild(gameDiv);
            }

            const scoreChart = createChart(document.getElementById('scoreChart').getContext('2d'), 'Average Score');
            const rewardChart = createChart(document.getElementById('rewardChart').getContext('2d'), 'Average Reward');
            const epsilonChart = createChart(document.getElementById('epsilonChart').getContext('2d'), 'Epsilon');

            const state_size = GRID_ROWS * GRID_COLS;
            const agent = new DQNAgent(state_size, ACTION_SIZE);
            const batch_size = 64;
            const update_target_freq = 200;

            const envs = Array(NUM_GAMES).fill(null).map((_, i) => {
                const canvas = document.querySelector(`#game-${i} .gameCanvas`);
                return new DiepIOEnv(i, canvas);
            });
            
            let states = envs.map(env => env.reset());
            let stepCount = 0;
            let totalRewardSinceLastChartUpdate = 0;
            let chartUpdateCount = 0;

            document.getElementById('toggleButton').addEventListener('click', () => {
                const newVisibility = !envs[0].ai_grid_visible;
                envs.forEach(env => env.ai_grid_visible = newVisibility);
            });

            async function gameLoop() {
                const actions = states.map(s => agent.act(s));

                for (let i = 0; i < NUM_GAMES; i++) {
                    if (envs[i].isRespawning) {
                        envs[i].step(0);
                        continue;
                    }

                    const [next_state, reward, done] = envs[i].step(actions[i]);
                    
                    totalRewardSinceLastChartUpdate += reward;

                    agent.remember(states[i], actions[i], reward, next_state, done);
                    states[i] = next_state;

                    if (done) {
                        agent.decay_epsilon();
                        envs[i].respawnPlayer();
                        states[i] = envs[i].get_state();
                    }
                }

                if (agent.memory.length > batch_size) {
                    await agent.replay(batch_size);
                }

                stepCount++;
                if (stepCount % update_target_freq === 0) {
                    agent.update_target_model();
                }
                
                envs.forEach(env => env.render());

                if (stepCount % 60 === 0) {
                    chartUpdateCount++;
                    const avgScore = envs.reduce((sum, env) => sum + env.score, 0) / NUM_GAMES;
                    const avgReward = totalRewardSinceLastChartUpdate / (NUM_GAMES * 60);
                    totalRewardSinceLastChartUpdate = 0;
                    
                    const update = (chart, data) => {
                        chart.data.labels.push(chartUpdateCount);
                        chart.data.datasets[0].data.push(data);
                        if (chart.data.labels.length > 50) {
                            chart.data.labels.shift();
                            chart.data.datasets[0].data.shift();
                        }
                        chart.update();
                    };

                    update(scoreChart, avgScore);
                    update(rewardChart, avgReward);
                    update(epsilonChart, agent.epsilon);
                }

                requestAnimationFrame(gameLoop);
            }

            gameLoop();
        }

        window.addEventListener('load', main);
    </script>
</body>
</html>