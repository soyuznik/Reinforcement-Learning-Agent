<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diep.io Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #cdcdcd;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            cursor: none;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #333;
            font-size: 18px;
            z-index: 100;
        }
        
        #levelBar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 20px;
            background: #555;
            border: 2px solid #333;
            z-index: 100;
        }
        
        #levelFill {
            height: 100%;
            background: #00b2e1;
            width: 0%;
            transition: width 0.2s;
        }
        
        #levelText {
            position: absolute;
            top: -25px;
            left: 0;
            color: #333;
            font-size: 14px;
        }
        
        #upgrades {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }
        
        .upgrade-btn {
            display: block;
            margin: 5px 0;
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .upgrade-btn:hover {
            background: #45a049;
        }
        
        .upgrade-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }
        
        #instructions h2 {
            margin-top: 0;
        }
        
        #startBtn {
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
        
        #startBtn:hover {
            background: #45a049;
        }
		#death-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            color: #1E90FF;
            font-size: 72px;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 24px;
            background: #333;
            color: white;
            border: #1E90FF;
            cursor: pointer;
		
		}
		.upgrade-btn {
            position: relative;
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 160px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .upgrade-value {
            font-size: 16px;
            background-color: rgba(0,0,0,0.2);
            padding: 2px 8px;
            border-radius: 12px;
        }
        
        /* Color assignments for full buttons */
        #healthUpgrade { background-color: #E49B5A; }
        #healthmaxUpgrade { background-color: #E24EE3; }
        #bodydamageUpgrade { background-color: #8072EC; }
        #bulletspeedUpgrade { background-color: #4C9FE6; }
        #bulletpenUpgrade { background-color: #E9D44D; }
        #damageUpgrade { background-color: #E34A45; }
        #reloadUpgrade { background-color: #8BE94A; color: #333; }
        #speedUpgrade { background-color: #55DCE9; color: #333; }
        
        /* Hover effects */
        .upgrade-btn:not([disabled]):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }
        
        .upgrade-btn:not([disabled]):active {
            transform: translateY(1px);
        }
        
        /* Disabled state */
        .upgrade-btn[disabled] {
            opacity: 0.7;
            filter: grayscale(30%);
            cursor: not-allowed;
        }


        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="instructions">
        <h2>Diep.io Clone</h2>
        <p>Use WASD or Arrow Keys to move</p>
        <p>Move mouse to aim, Click to shoot</p>
        <p>Destroy shapes and enemy tanks to gain XP</p>
        <p>Level up to unlock upgrades</p>
        <button id="startBtn">Start Game</button>
    </div>
	
	<div id="death-screen">
        <h2>You died!</h2>
        <button id="restartBtn">Restart</button>
    </div>
    
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Level: <span id="level">1</span></div>
    </div>
    
    <div id="levelBar">
        <div id="levelText">Level 1</div>
        <div id="levelFill"></div>
    </div>
	
	
    <div id="upgrades">
    <button class="upgrade-btn" id="healthUpgrade" disabled>
        <span class="upgrade-text">Health Regen</span>
        <span class="upgrade-value" >0</span>
    </button>
    <button class="upgrade-btn" id="healthmaxUpgrade" disabled>
        <span class="upgrade-text">Max Health</span>
        <span class="upgrade-value" >0</span>
    </button>
	<button class="upgrade-btn" id="bodydamageUpgrade" disabled>
        <span class="upgrade-text">Body Damage</span>
        <span class="upgrade-value" >0</span>
    </button>
	<button class="upgrade-btn" id="bulletspeedUpgrade" disabled>
        <span class="upgrade-text">Bullet Speed</span>
        <span class="upgrade-value" >0</span>
    </button>
	<button class="upgrade-btn" id="bulletpenUpgrade" disabled>
        <span class="upgrade-text">Bullet Penetration</span>
        <span class="upgrade-value" >0</span>
    </button>
	<button class="upgrade-btn" id="damageUpgrade" disabled>
        <span class="upgrade-text">Bullet Damage</span>
        <span class="upgrade-value" >0</span>
    </button>
	<button class="upgrade-btn" id="reloadUpgrade" disabled>
        <span class="upgrade-text">Reload Speed</span>
        <span class="upgrade-value" >0</span>
    </button>
	<button class="upgrade-btn" id="speedUpgrade" disabled>
        <span class="upgrade-text">Movement Speed</span>
        <span class="upgrade-value" >0</span>
    </button>
    <!-- Repeat for other buttons with different colors -->
    </div>
	
	
    

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let gameRunning = false;
        let mouseX = 0;
        let mouseY = 0;
        let cameraX = 0;
        let cameraY = 0;
        let isMouseDown = false;
		const mouse = { x: 0, y: 0 };
        // Input handling
        const keys = {};
        
        // Game objects
        let player = null;
        let bullets = [];
        let enemies = [];
        let shapes = [];
        let particles = [];
        
        // Stats
        let score = 0;
        let level = 1;
        let xp = 0;
        let xpToNext = 100;
        let skillPoints = 0;
        let epsilon = 30;
		let epsilon_decay = 0.9999;
		let player_class = 'trapper';
        // Upgrades
        let upgrades = {
		    health_reg: 0,
            health: 0,
			body_damage: 0,
			bullet_speed: 0,
			penetration: 0,
            damage: 0,   // !!! the upgrade is called damage NOT this.entity_upgrade.bullet_damage.
            reload: 0,
			speed: 0
            
        };
        
		function drawXCursor(x, y, size = 20, color = 'black', thickness = 2) {
            ctx.save(); // Save current canvas state
    
            // Set styles
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            
            // Move to cursor position and rotate 45 degrees
            ctx.translate(x, y);
            ctx.rotate(Math.PI / 4); // 45 degrees in radians
            
            // Draw plus sign (will appear as X after rotation)
            ctx.beginPath();
            // Horizontal line
            ctx.moveTo(-size/2, 0);
            ctx.lineTo(size/2, 0);
            // Vertical line
            ctx.moveTo(0, -size/2);
            ctx.lineTo(0, size/2);
            ctx.stroke();
            
            ctx.restore(); // Restore canvas state
        }
		
        class Tank {
            constructor(x, y, isPlayer = false) {
			    this.class = 'tank';
			    if(isPlayer == false){ // <CLASS>
				   const classes = ['tank', 'twin', 'sniper', 'machine_gun', 'flank_guard' , 'destroyer' , 'gunner',
				   'tri_angle', 'twin_flank', 'quad_tank' , 'auto_3', 'assasin' , 'tripleshot' , 'overseer' , 'hunter', 'trapper'];
                   this.class = classes[Math.floor(Math.random() * classes.length)];
				}
				else{
				   this.class = player_class;
				}
				
				
				this.entity_upgrades = isPlayer ? upgrades : {
		            health_reg: 0,
                    health: 0,
		        	body_damage: 0,
		        	bullet_speed: 0,
		        	penetration: 0, // same here.
                    damage: 0,  // !!! the upgrade is called damage NOT this.entity_upgrade.bullet_damage.
                    reload: 0,
		        	speed: 0
                    
                };
				// tank stats
				this.maxSpeed = 3; // Store base speed
				this.acceleration = 0.2;
				this.maxHealth = 100;
				this.body_damage = 20;
				this.shootCooldown = 600;
				this.bullet_speed = 9;
				this.bullet_pen = 10;
				this.bullet_damage = 7;
			
				this.entity_level = isPlayer ? level : (Math.floor(Math.random() * 45) + 1)
				
				// handle classes; <CLASS>
				if(this.class == 'machine_gun' || this.class == 'auto_3'){
				    this.shootCooldown = 120;
				}
				else if(this.class == 'sniper'){
				    this.shootCooldown = 700;
				}
				else if(this.class == 'flank_guard' || this.class == 'tri_angle' || this.class == 'quad_tank' || this.class == 'twin_flank'){
				    this.shootCooldown = 300;
				}
				else if(this.class == 'twin' || this.class == 'tripleshot'){
				    this.shootCooldown = 230;
				}
				else if(this.class == 'destroyer'){
				    this.shootCooldown = 2000;
				}
				else if(this.class == 'assasin'){
				    this.shootCooldown = 700;
					
				}
				
				
				
                this.x = x;
                this.y = y;
				this.velocity = { x: 0, y: 0 };
                this.friction = 0.93; // Friction coefficient (0.9-0.99)
                this.speed = 0; // Current speed
                this.size = 30;
                this.health = 100;
				//healing stats
				this.lastDamageTime = 0;
                this.healDelay = 5000; // 5 seconds delay
                this.baseHealRate = 2; // HP per second
                this.healInterval = 1000; // Heal every second
                this.lastHealTime = 0;
				
                this.angle = 0;
                this.isPlayer = isPlayer;
                this.color = isPlayer ? '#00b2e1' : '#f14e54';
                this.barrelLength = 55;
                this.barrelWidth = 20;
				this.barrelType = this.class;
                this.lastShot = 0;
				this.twinToggle = false; // for alternating twin fire
				this.recentlyHit = false; // For damage cooldown
                this.lastCollisionTime = 0; // Track collision timing
				
				this.barrelShake = {
                    intensity: 0,
                    offset: { x: 0, y: 0 },
                    maxIntensity: 5,         // Maximum recoil distance
                    isRecoiling: false,      // Track recoil state
                    recoilSpeed: 0.3,        // Speed of recoil animation
                    returnSpeed: 0.2,        // Speed of return animation
                    active: false            // New flag to track active state
                };
				this.recoilForce = 0;
                this.maxRecoil = this.isPlayer ? 2 : 1; // I get
				if(this.class =='flank_guard'){
				     this.maxRecoil = 0;
				}
				else if (this.class === 'gunner') {
                    this.barrelLength = 55;
                    this.barrelWidth = 10;
                }
				else if( this.class == 'assasin'){
				     this.barrelLength = 65;
				}
				else if(this.class == 'hunter'){
				    this.barrelShake.maxIntensity = 2;
				}
				else if(this.class == 'flank_guard' || this.class == 'trapper'){
				    this.barrelShake.maxIntensity = 0;
				}
                this.recoilDecay = 0.9;
                this.ai = isPlayer ? null : {
                    target: null,
                    lastDirection: 0,
                    changeDirection: 0
                };
            }
            
            update() {
                if (this.isPlayer) {
                    this.updatePlayer();
                } else {
                    this.updateAI();
                }
                if (this.recoilForce > 0.1) {
                    this.x -= Math.cos(this.angle) * this.recoilForce;
                    this.y -= Math.sin(this.angle) * this.recoilForce;
                    this.recoilForce *= this.recoilDecay;
                } else {
                    this.recoilForce = 0;
                }
				
                // Health regeneration (only if not at max health)
                if (this.health < this.maxHealth) {
                    const now = Date.now();
                    
                    // Check if 5 seconds have passed since last damage
                    if (now - this.lastDamageTime > this.healDelay) {
                        
                        // Check if it's time to heal (once per second)
                        if (now - this.lastHealTime > this.healInterval) {
                            const healAmount = this.baseHealRate + (this.entity_upgrades.health_reg * 0.7);
                            this.health = Math.min(this.health + healAmount, this.maxHealth);
                            this.lastHealTime = now;
                            
                            // Optional: Add heal particles
                            if (this.isPlayer) {
                                particles.push(new Particle(
                                    this.x, this.y, 
                                    '#00FF00', // Green heal effect
                                     'plus'
                                ));
                            }
                        }
                    }
                } 
				
				// regen
				this.baseHealRate = this.maxHealth * (0.03 + (this.entity_upgrades.health_reg * 0.018));
				// Max hp
				this.maxHealth = 50 + (2 * (this.entity_level - 1)) + (this.entity_upgrades.health * 20);// exactly diep io
				//if(this.isPlayer) console.log("this health is "  + this.maxHealth);
				//this.health = Math.min(this.health, this.maxHealth); // Preserve current health but cap at max
				//body damage
				this.body_damage = 1 + ((this.entity_upgrades.body_damage +5 ) * 4);
				// bullet speed
				this.bullet_speed = 4 + (this.entity_upgrades.bullet_speed * 2);
				//bullet penetration
				this.bullet_pen = 2 + (1.5 * this.entity_upgrades.penetration);
				//bullet damage
				
				// !!! the upgrade is called damage NOT this.entity_upgrade.bullet_damage.
				this.bullet_damage = 7 + (3 * this.entity_upgrades.damage);
				
				// reload
				this.shootCooldown = 600 - (40 * this.entity_upgrades.reload);
				// max speed
				this.maxSpeed = 3 +( this.entity_upgrades.speed * 0.5);
				
				
				if (this.health <= 0 && this.isPlayer) {
				// dead
                     document.getElementById('death-screen').style.display = 'flex';
					 gameRunning = false;
                }
				// Barrel recoil animation
                if (this.barrelShake.active) {
                    if (!this.barrelShake.isRecoiling) {
                        // Recoil phase - move backward
                        const recoilX = Math.cos(this.angle) * this.barrelShake.recoilSpeed;
                        const recoilY = Math.sin(this.angle) * this.barrelShake.recoilSpeed;
                        
                        this.barrelShake.offset.x -= recoilX;
                        this.barrelShake.offset.y -= recoilY;
                        
                        // Check if reached max recoil
                        const currentOffset = Math.hypot(this.barrelShake.offset.x, this.barrelShake.offset.y);
                        if (currentOffset >= this.barrelShake.maxIntensity) {
                            this.barrelShake.isRecoiling = true;
                        }
                    } else {
                        // Return phase - smooth return
                        this.barrelShake.offset.x *= (1 - this.barrelShake.returnSpeed);
                        this.barrelShake.offset.y *= (1 - this.barrelShake.returnSpeed);
                        
                        // Check if completed
                        if (Math.hypot(this.barrelShake.offset.x, this.barrelShake.offset.y) < 0.1) {
                            this.barrelShake.offset = { x: 0, y: 0 };
                            this.barrelShake.active = false;
                            this.barrelShake.intensity = 0;
                            this.barrelShake.isRecoiling = false;
                        }
                    }
                }
				for (const other of enemies.concat(player)) {
                    if (other === this) continue;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const minDist = this.size + other.size;
                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
	                
                        if (this.isPlayer) {
                            // Player gets pushed back
                            this.x -= nx * overlap * 0.5;
                            this.y -= ny * overlap * 0.5;
                        } else {
                            // Enemy gets pushed away
                            other.x += nx * overlap * 0.5;
                            other.y += ny * overlap * 0.5;
                        }
						// Apply mutual damage
                         if (!this.recentlyHit) {
                             if(this.takeDamage(other.body_damage) && this.isPlayer){
							     document.getElementById('death-screen').style.display = 'flex';
					             gameRunning = false;
							 }
                             if(other.takeDamage(this.body_damage)){
							      enemies.splice(enemies.indexOf(other), 1);
								  particles.push(new DeathEffect(other.x, other.y, this.angle, other.color));
								  addXP(100); // 100 exp per tank kill;
							 }
                             
                             
							 if(this.speed < 10){// Add cooldown to prevent rapid damage
                                this.recentlyHit = true;
                                setTimeout(() => this.recentlyHit = false, 500);
							 }
                         }
                    }
                }
				for (const shape of shapes) {
                     const dx = shape.x - this.x;
                     const dy = shape.y - this.y;
                     const dist = Math.hypot(dx, dy);
                     const minDist = this.size + shape.size;
                     
                     if (dist < minDist) {
                         // Calculate push direction
                         const nx = dx / dist;
                         const ny = dy / dist;
                         const overlap = minDist - dist;
                         
                         // Size-based push factors (pentagon pushes more)
                         const shapePushFactor = shape.type === 'pentagon' ? 0.7 : 
                                              shape.type === 'triangle' ? 0.5 : 0.4;
                         const playerPushFactor = 0.5;
                         
                         // Apply push to both
                         this.x -= nx * overlap * playerPushFactor;
                         this.y -= ny * overlap * playerPushFactor;
                         shape.x += nx * overlap * shapePushFactor;
                         shape.y += ny * overlap * shapePushFactor;
                         
                         // Apply mutual damage
                         if (!this.recentlyHit) {
                             if(this.takeDamage(shape.body_damage) && this.isPlayer){
							     document.getElementById('death-screen').style.display = 'flex';
					             gameRunning = false;
							 }
                             if(shape.takeDamage(this.body_damage)){
							      shapes.splice(shapes.indexOf(shape), 1);
								  particles.push(new DeathEffect(shape.x, shape.y, this.angle, shape.color));
								  addXP(shape.xp); // shape exp per shape kill;
							 }
                             
                             if(this.speed < 10){// Add cooldown to prevent rapid damage
                                this.recentlyHit = true;
                                setTimeout(() => this.recentlyHit = false, 500);
							 }
                         }
                         
                         // Create collision particles
                         for (let i = 0; i < 3; i++) {
                             particles.push(new Particle(
                                 (this.x + shape.x) / 2,
                                 (this.y + shape.y) / 2,
                                 this.color
                             ));
                         }
                     }
               }
            }
            
            updatePlayer() {
			    this.level = level;
                // Handle acceleration-based movement
                let moveX = 0;
                let moveY = 0;
                
                // Get input direction
                if (keys['w'] || keys['ArrowUp']) moveY -= 1;
                if (keys['s'] || keys['ArrowDown']) moveY += 1;
                if (keys['a'] || keys['ArrowLeft']) moveX -= 1;
                if (keys['d'] || keys['ArrowRight']) moveX += 1;
	            
                // Normalize diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    const len = Math.sqrt(moveX * moveX + moveY * moveY);
                    moveX /= len;
                    moveY /= len;
                }
	            
                // Apply acceleration
                const effectiveMaxSpeed = this.maxSpeed + upgrades.speed;
                if (moveX !== 0 || moveY !== 0) {
                    this.velocity.x += moveX * this.acceleration;
                    this.velocity.y += moveY * this.acceleration;
                    
                    // Limit speed
                    const currentSpeed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                    if (currentSpeed > effectiveMaxSpeed) {
                        const ratio = effectiveMaxSpeed / currentSpeed;
                        this.velocity.x *= ratio;
                        this.velocity.y *= ratio;
                    }
                } else {
                    // Apply friction when no input
                    this.velocity.x *= this.friction;
                    this.velocity.y *= this.friction;
                }
	            
                // Apply recoil (modifies velocity directly)
                if (this.recoilForce > 0.1) {
                    this.velocity.x -= Math.cos(this.angle) * this.recoilForce * 0.5;
                    this.velocity.y -= Math.sin(this.angle) * this.recoilForce * 0.5;
                    this.recoilForce *= this.recoilDecay;
                } else {
                    this.recoilForce = 0;
                }
	            
                // Update position
                this.x += this.velocity.x;
                this.y += this.velocity.y;
	            
                // Keep in bounds (with bounce effect)
                const bounce = 0.6;
                if (this.x < this.size) {
                    this.x = this.size;
                    this.velocity.x *= -bounce;
                } else if (this.x > 4000 - this.size) {
                    this.x = 4000 - this.size;
                    this.velocity.x *= -bounce;
                }
                if (this.y < this.size) {
                    this.y = this.size;
                    this.velocity.y *= -bounce;
                } else if (this.y > 4000 - this.size) {
                    this.y = 4000 - this.size;
                    this.velocity.y *= -bounce;
                }
	            
                // Aiming (unchanged)
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                this.angle = Math.atan2(worldMouseY - this.y, worldMouseX - this.x);
			    
            }
            
            updateAI() {
                const now = Date.now();
                
                // Find closest target
                let closestDist = Infinity;
                let target = null;
                
				// Check for bullets #1 priority
                for (const bullet of bullets) {
				    if(!bullet.fromPlayer) continue;
					
                    const dist = Math.hypot(bullet.x - this.x, bullet.y - this.y);
                    if (dist < closestDist && dist < 200) {
                        target = bullet;
                        closestDist = dist;
                    }
                }
				// check player #2
                if (player) {
                    const dist = Math.hypot(player.x - this.x, player.y - this.y);
                    if (dist < 900) {
                        target = player;
                        closestDist = dist;
                    }
                }
				// Check for shapes #3
                for (const shape of shapes) {
                    const dist = Math.hypot(shape.x - this.x, shape.y - this.y);
                    if (dist < closestDist && dist < 400) {
                        target = shape;
                        closestDist = dist;
                    }
                }
                
                this.ai.target = target;
                
                if (target) {
                    // Move towards target
                    // Calculate direction to target
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const dirX = dx / dist;
                    const dirY = dy / dist;
		            
                    // Apply acceleration toward target
                    if (dist > 100) {
                        this.velocity.x += dirX * this.acceleration;
                        this.velocity.y += dirY * this.acceleration;
                    } else if (dist < 80) {
                        // Back away if too close
                        this.velocity.x -= dirX * this.acceleration * 0.5;
                        this.velocity.y -= dirY * this.acceleration * 0.5;
                    }
		            
                    // Limit speed
                    const currentSpeed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                    if (currentSpeed > this.maxSpeed) {
                        const ratio = this.maxSpeed / currentSpeed;
                        this.velocity.x *= ratio;
                        this.velocity.y *= ratio;
                    }
                    
                    // Aim at target
                    this.angle = Math.atan2(dy, dx);
                    
                    // Shoot at target
                    if (now - this.lastShot > this.shootCooldown) {
                        this.shoot(this.class);
                    }
                } else {
                    // Wandering behavior with acceleration
                    if (now > this.ai.changeDirection) {
                        this.ai.lastDirection = Math.random() * Math.PI * 2;
                        this.ai.changeDirection = now + 2000 + Math.random() * 3000;
                    }
                    
                    this.velocity.x += Math.cos(this.ai.lastDirection) * this.acceleration * 0.5;
                    this.velocity.y += Math.sin(this.ai.lastDirection) * this.acceleration * 0.5;
                    this.angle = this.ai.lastDirection;
                }
                // Apply friction
                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
	            
                // Update position
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                // Keep in bounds
                this.x = Math.max(this.size, Math.min(4000 - this.size, this.x));
                this.y = Math.max(this.size, Math.min(4000 - this.size, this.y));
				
				
            }
            
            shoot(of_class = 'tank') {
                const now = Date.now();
                const cooldown = this.shootCooldown;
				
                if (now - this.lastShot < cooldown) return;
				
				// Activate recoil systems <CLASS>
                if (this.barrelShake.maxIntensity > 0) {
                    this.barrelShake.intensity = this.barrelShake.maxIntensity;
                    this.barrelShake.isRecoiling = false;
                    this.barrelShake.active = true;
                    this.barrelShake.offset = { x: 0, y: 0 }; // Reset offset
                }
                this.lastShot = now;
	            
                const baseX = this.x;
                const baseY = this.y;
	            
                // General helper to spawn a bullet at a given angle
                const fireBullet = (angle) => {
                    const bulletX = baseX + Math.cos(angle) * this.barrelLength;
                    const bulletY = baseY + Math.sin(angle) * this.barrelLength;
                    bullets.push(new Bullet(bulletX, bulletY, angle, this.isPlayer, of_class, this.bullet_speed, this.bullet_damage, this.bullet_pen));
                };
	            
                // Class-specific shooting <CLASS>
                switch (of_class) {
                    case 'flank_guard': {
					    const spread = 0.15;
					    const randomOffset = (Math.random() - 0.5) * spread;
                        fireBullet(this.angle + randomOffset);                     // forward
                        fireBullet(this.angle + Math.PI + randomOffset);           // backward
                        break;
	                }
					case 'tripleshot': {
					    const spread = 0.15;
					    const randomOffset = (Math.random() - 0.5) * spread;
                        fireBullet(this.angle + randomOffset);                     // forward
                        fireBullet(this.angle + (0.15* Math.PI) + randomOffset);           // side
						fireBullet(this.angle + (-0.15* Math.PI) + randomOffset);           // side
                        break;
	                }
                    case 'twin':  {
					    const spread = 0.15;
					    const randomOffset = (Math.random() - 0.5) * spread;
                        const twinOffset = 0.15; // radians
                        const angleOffset = this.twinToggle ? -twinOffset : twinOffset;
                        this.twinToggle = !this.twinToggle;
                        fireBullet(this.angle + angleOffset + randomOffset);
                        break;
	                }
                    case 'machine_gun': {
                        const spread = 0.3; // max spread in radians
                        const randomOffset = (Math.random() - 0.5) * spread;
                        fireBullet(this.angle + randomOffset);
                        break;
	                }
					case 'gunner': {
                        const spread = 0.12; // minor angle spread
                        const baseAngle = this.angle;
                        const angles = [-0.1, -0.03, 0.03, 0.1]; // simulate spread from 4 barrels
                        //this.twinToggle = !this.twinToggle;
						let shootgnn = [0 , 1, 0 , 1];
						//if(this.twinToggle) {
						    
						//}
						let left = false;
                        for (let i = 0; i < angles.length; i++) {
						    if(!shootgnn[i]) continue;
							const tankRadius = 30;
							const randomOffset = 0;//(Math.random() - 0.5) * spread;
							const gnnangle = baseAngle + angles[i] + randomOffset;
							let perpendicularAngle = gnnangle + Math.PI / 2; // 90° from tank direction
							if(left) perpendicularAngle += Math.PI;
                            left = !left;
                            const edgeX = baseX + Math.cos(perpendicularAngle) * tankRadius;
                            const edgeY = baseY + Math.sin(perpendicularAngle) * tankRadius;
							
							
							let gnnbulletX = edgeX + Math.cos(gnnangle) * this.barrelLength;
                            let gnnbulletY = edgeY + Math.sin(gnnangle) * this.barrelLength;
							gnnbulletX -= angles[i] * 5;
							gnnbulletY -= angles[i] * 5;
                            bullets.push(new Bullet(gnnbulletX, gnnbulletY, gnnangle, this.isPlayer, of_class, this.bullet_speed, this.bullet_damage, this.bullet_pen));
                            
                        }
						shootgnn = [1 , 0, 1 , 0];
						for (let i = 0; i < angles.length; i++) {
						    if(!shootgnn[i]) continue;
							const tankRadius = 20;
							const randomOffset = 0;//(Math.random() - 0.5) * spread;
							const gnnangle = baseAngle + angles[i] + randomOffset;
							let perpendicularAngle = gnnangle + Math.PI / 2; // 90° from tank direction
							if(left) perpendicularAngle += Math.PI;
                            left = !left;
                            const edgeX = baseX + Math.cos(perpendicularAngle) * tankRadius;
                            const edgeY = baseY + Math.sin(perpendicularAngle) * tankRadius;
							
							
							let gnnbulletX = edgeX + Math.cos(gnnangle) * this.barrelLength;
                            let gnnbulletY = edgeY + Math.sin(gnnangle) * this.barrelLength;
							gnnbulletX -= angles[i] * 5;
							gnnbulletY -= angles[i] * 5;
                            bullets.push(new Bullet(gnnbulletX, gnnbulletY, gnnangle, this.isPlayer, of_class, this.bullet_speed, this.bullet_damage, this.bullet_pen));
                            
                        }
                        break;
                    }
					case 'tri_angle': {
                        const spread = 0.1; // max spread in radians
                        const randomOffset = (Math.random() - 0.5) * spread;
                        bullets.push(new Bullet(baseX + Math.cos(this.angle) * this.barrelLength,baseY + Math.sin(this.angle) * this.barrelLength, 
						  this.angle + randomOffset, this.isPlayer, of_class, this.bullet_speed * 1.5, this.bullet_damage, this.bullet_pen));
						fireBullet(this.angle + (5/6) * Math.PI); // back turrets
						fireBullet(this.angle - (5/6) * Math.PI); // back turrets
                        break;
	                }
					case 'quad_tank':{
					    const spread = 0.15; // max spread in radians
                        const randomOffset = (Math.random() - 0.5) * spread;
                        fireBullet(this.angle + randomOffset);
						fireBullet(this.angle + Math.PI + randomOffset); // back turret
						fireBullet(this.angle - (Math.PI/2) + randomOffset); // side
						fireBullet(this.angle + (Math.PI/2) + randomOffset); // side
                        break;
					
					}
					case 'twin_flank':{
					    const spread = 0.15;
					    const randomOffset = (Math.random() - 0.5) * spread;
                        const twinOffset = 0.15; // radians
                        const angleOffset = this.twinToggle ? -twinOffset : twinOffset;
                        this.twinToggle = !this.twinToggle;
                        fireBullet(this.angle + angleOffset + randomOffset);
                        fireBullet(this.angle + angleOffset + randomOffset + Math.PI);
						break;
					}// ********************************************************
					//                                                          *
                    case 'auto_3': { /// ADD AUTO TURRET !!!                    *
					//********************************************************  *
					    const baseAngle = this.angle;
					    const tankRadius = 30;
					    const angles = [0.5 , 1 , 0];
						const spread = 0.15; // max spread in radians
						const randomOffset = (Math.random() - 0.5) * spread;
						const gnnangle = baseAngle + randomOffset;
						let triAngle = gnnangle + (2*(Math.PI / 3)); // 120° from tank direction
					    
                        
						const edgeX = baseX + Math.cos(triAngle) * tankRadius;
                        const edgeY = baseY + Math.sin(triAngle) * tankRadius;
						
						
						let gnnbulletX = edgeX + Math.cos(gnnangle) * this.barrelLength;
                        let gnnbulletY = edgeY + Math.sin(gnnangle) * this.barrelLength;
                         bullets.push(new Bullet(gnnbulletX, gnnbulletY, gnnangle, this.isPlayer, of_class, this.bullet_speed, this.bullet_damage, this.bullet_pen));
                        fireBullet(this.angle + randomOffset); // first
						//fireBullet(this.angle + randomOffset); // back turret
						//fireBullet(this.angle + randomOffset); // side
	
                        break;
					}
                    case 'hunter': {
					
					    const bulletX = baseX + Math.cos(this.angle) * this.barrelLength;
                        const bulletY = baseY + Math.sin(this.angle) * this.barrelLength;
						// small bullet
                        bullets.push(new Bullet(bulletX, bulletY, this.angle, this.isPlayer, of_class, this.bullet_speed + 2, this.bullet_damage, this.bullet_pen, 5));
						bullets.push(new Bullet(bulletX , bulletY, this.angle, this.isPlayer, of_class, this.bullet_speed, this.bullet_damage, this.bullet_pen, 9));
					    break;
					}
					case 'trapper': {
					    const spread = 0.55;
					    const randomOffset = (Math.random() - 0.5) * spread;
					    const bulletX = baseX + Math.cos(this.angle) * this.barrelLength;
                        const bulletY = baseY + Math.sin(this.angle) * this.barrelLength;
						// small bullet
                        bullets.push(new Bullet(bulletX, bulletY, this.angle + randomOffset, this.isPlayer, of_class, this.bullet_speed, this.bullet_damage, this.bullet_pen));
						
					    break;
					}
					
					// def tank.
					default: {
					    const spread = 0.15;
					    const randomOffset = (Math.random() - 0.5) * spread;
                        fireBullet(this.angle + randomOffset);
                        break;
					}
					
                }
            }
            
            takeDamage(damage) {
                this.health -= damage;
                this.lastDamageTime = Date.now(); // Reset timer on damage
                // Create damage particles
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(this.x, this.y, '#ff0000'));
                }
                
                return this.health <= 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - cameraX, this.y - cameraY);
                
				// Tank barrel (DEFAULT) <CLASS>
				ctx.save();
				ctx.translate(this.barrelShake.offset.x, this.barrelShake.offset.y);
				//
				// to remove shake ********** OLD SYSTEM..
				//         ctx.restore();
				//         ctx.save();
				//         ctx.rotate(this.angle);
				  //       or
				  //        this.barrelShake.maxIntensity = 0; --> in class initialization
				// *****************************
				ctx.rotate(this.angle);
				if(this.class == 'tank'){
                    ctx.fillStyle = "#d3d3d3";
                    ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
				}
				else if (this.class === 'twin') { // twin
				    ctx.lineWidth = 2;
                    ctx.fillStyle = "#d3d3d3";
                    const offset = 15;
					
                    ctx.fillRect(0, -this.barrelWidth/2.3 - offset, this.barrelLength, this.barrelWidth);
					ctx.strokeStyle = '#000';
                    ctx.strokeRect(0, -this.barrelWidth/2.3 - offset, this.barrelLength, this.barrelWidth);
                    ctx.fillRect(0, -this.barrelWidth/2.3 + offset, this.barrelLength, this.barrelWidth);
                    ctx.strokeRect(0, -this.barrelWidth/2.3 + offset, this.barrelLength, this.barrelWidth);
                }
				else if (this.class === 'sniper' || this.class == 'assasin') { // twin
                    // adjusted lenght;
                    ctx.fillStyle = "#d3d3d3";
                    ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength * 1.15, this.barrelWidth);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength * 1.15, this.barrelWidth);
                }
				else if (this.class === 'flank_guard') {
                   // Front barrel
				   ctx.lineWidth = 2;
				   ctx.fillStyle = "#d3d3d3";
				   ctx.strokeStyle = '#000';
                   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   
                   // Back barrel (rotate 180 degrees)
                   ctx.rotate(Math.PI);
                   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                }
				else if(this.class == 'machine_gun'){
				    ctx.fillStyle = "#d3d3d3";
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
	                
                    ctx.beginPath();
                    ctx.moveTo(0, -this.barrelWidth/2); // top left
                    ctx.lineTo(this.barrelLength, -this.barrelWidth); // top right
                    ctx.lineTo(this.barrelLength, this.barrelWidth);  // bottom right
                    ctx.lineTo(0, this.barrelWidth/2);  // bottom left
                    ctx.closePath();
	                
                    ctx.fill();
                    ctx.stroke();
				}
				else if(this.class == 'destroyer'){
				    ctx.fillStyle = "#d3d3d3";
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
	                
                    ctx.beginPath();
                    ctx.moveTo(0, -this.barrelWidth); // top left
                    ctx.lineTo(this.barrelLength, -this.barrelWidth); // top right
                    ctx.lineTo(this.barrelLength, this.barrelWidth);  // bottom right
                    ctx.lineTo(0, this.barrelWidth);  // bottom left
                    ctx.closePath();
	                
                    ctx.fill();
                    ctx.stroke();
				}
				else if (this.class === 'gunner') {
                    ctx.lineWidth = 2;
                    ctx.fillStyle = "#d3d3d3";
                    ctx.strokeStyle = '#000';
                
                    const offset = 9; // spacing between barrels
                
                    // Left pair
                    ctx.fillRect(0, -this.barrelWidth/1.2 - offset - 12, this.barrelLength - 15, this.barrelWidth); // shorter one, edge
                    ctx.strokeRect(0, -this.barrelWidth/1.2 - offset - 12, this.barrelLength - 15, this.barrelWidth);
                    ctx.fillRect(0, this.barrelWidth/1.5 - offset - 16, this.barrelLength - 3, this.barrelWidth * 1.5);
                    ctx.strokeRect(0, this.barrelWidth/1.5 - offset - 16, this.barrelLength - 3 , this.barrelWidth * 1.5);
					
                
                    // Right pair
					ctx.fillRect(0, this.barrelWidth/1.2 + offset + 2, this.barrelLength - 15, this.barrelWidth); // shorter one , edge
                    ctx.strokeRect(0, this.barrelWidth/1.2 + offset + 2, this.barrelLength - 15, this.barrelWidth);
                    ctx.fillRect(0, -this.barrelWidth/1.5 + offset + 2, this.barrelLength - 3, this.barrelWidth * 1.5);
                    ctx.strokeRect(0, -this.barrelWidth/1.5 + offset + 2, this.barrelLength - 3, this.barrelWidth * 1.5);
                    
                }
				else if(this.class == 'tri_angle'){
				    ctx.restore();
                    // FRONT BARREL WITH SHAKE
                    ctx.save();
                    ctx.rotate(this.angle);
                    ctx.fillStyle = "#d3d3d3";
                    ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                    ctx.restore(); // restore after front barrel
	                
                    // BACK BARRELS WITHOUT SHAKE
                    ctx.save();
                    ctx.rotate(this.angle);
	                ctx.translate(this.barrelShake.offset.x, this.barrelShake.offset.y); // shake only here
                    ctx.rotate((5/6) * Math.PI);
                    ctx.fillStyle = "#d3d3d3";
                    ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength * (5/6), this.barrelWidth);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength * (5/6), this.barrelWidth);
	                
                    ctx.rotate(-2 * (5/6) * Math.PI);
                    ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength * (5/6), this.barrelWidth);
                    ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength * (5/6), this.barrelWidth);
                }
				else if (this.class === 'quad_tank') {
				   ctx.restore();
				   ctx.save();
				   ctx.rotate(this.angle);
				   
                   // Front barrel
				   ctx.lineWidth = 2;
				   ctx.fillStyle = "#d3d3d3";
				   ctx.strokeStyle = '#000';
                   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   
                   // Back barrel (rotate 180 degrees)
                   ctx.rotate(Math.PI);
                   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
				   
				   ctx.rotate(Math.PI/2);
				   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
				   
				   ctx.rotate(Math.PI);
				   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                }
				else if (this.class === 'twin_flank') { // twin flank
				    ctx.restore();
				   ctx.save();
				   ctx.rotate(this.angle);
				    ctx.lineWidth = 2;
                    ctx.fillStyle = "#d3d3d3";
                    const offset = 15;
					
                    ctx.fillRect(0, -this.barrelWidth/2.3 - offset - 3, this.barrelLength, this.barrelWidth);
					ctx.strokeStyle = '#000';
                    ctx.strokeRect(0, -this.barrelWidth/2.3 - offset - 3, this.barrelLength, this.barrelWidth);
                    ctx.fillRect(0, -this.barrelWidth/2.3 + offset, this.barrelLength, this.barrelWidth);
                    ctx.strokeRect(0, -this.barrelWidth/2.3 + offset, this.barrelLength, this.barrelWidth);
					ctx.rotate(Math.PI);
					ctx.fillRect(0, -this.barrelWidth/2.3 - offset - 3, this.barrelLength, this.barrelWidth);
					ctx.strokeStyle = '#000';
                    ctx.strokeRect(0, -this.barrelWidth/2.3 - offset - 3, this.barrelLength, this.barrelWidth);
                    ctx.fillRect(0, -this.barrelWidth/2.3 + offset, this.barrelLength, this.barrelWidth);
                    ctx.strokeRect(0, -this.barrelWidth/2.3 + offset, this.barrelLength, this.barrelWidth);
                }
				else if (this.class == 'auto_3') {// Looks crazy good!
				        ctx.restore();
						ctx.save();
						ctx.rotate(this.angle);
                        for (let i = 0; i < 3; i++) {
						   
                            const baseAngle = this.angle + i * (2 * Math.PI / 3);
                            const turretOffset = 30;
							const bx = this.x + Math.cos(baseAngle) * turretOffset;
                            const by = this.y + Math.sin(baseAngle) * turretOffset;
                            const turretBaseRadius = 12;
                    
                            // Outward by default
							// DOnt know what this does for now. 
							//for some reason target Angle is not this.angle
                            let dx = mouse.x - (this.x + Math.cos(baseAngle) * turretOffset);
                            let dy = mouse.y - (this.y + Math.sin(baseAngle) * turretOffset);
                            let targetAngle = Math.atan2(dy, dx);
                    
                            // Flip logic (optional, to prevent backfiring)
                            let diff = (targetAngle - baseAngle) % (2 * Math.PI);
                            if (diff < 0) diff += 2 * Math.PI;
                            if (diff > Math.PI/2 && diff < 3 * Math.PI/2) {
                                targetAngle += Math.PI;
                            }
                    
                            ctx.save();
                            // Already translated to tank center — just offset locally
                            ctx.translate(Math.cos(baseAngle) * turretOffset, 
							        Math.sin(baseAngle) * turretOffset);
                            
							// Draw barrel
                            ctx.rotate(targetAngle);
                            ctx.fillStyle = '#d3d3d3';
                            ctx.fillRect(0, -this.barrelWidth / 2, this.barrelLength * (1.5/3),
                     							this.barrelWidth * (2/3));
                            ctx.strokeRect(0, -this.barrelWidth / 2, this.barrelLength * (1.5/3),
                    							this.barrelWidth * (2/3));
                            
                            // Draw turret base
                            ctx.fillStyle = '#888';
                            ctx.beginPath();
                            ctx.arc(0, 0, turretBaseRadius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                    
                            
                            ctx.restore();
                        }
                    }/////////////
                else if(this.class == 'tripleshot'){
                   // Front barrel
				   ctx.lineWidth = 2;
				   ctx.fillStyle = "#d3d3d3";
				   ctx.strokeStyle = '#000';
                   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   
                   // side barrel 
                   ctx.rotate(0.2 * Math.PI);
                   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
				   
				   // side barrel 
                   ctx.rotate(-0.4 * Math.PI);
                   ctx.fillRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
                   ctx.strokeRect(0, -this.barrelWidth/2, this.barrelLength, this.barrelWidth);
				}
				else if(this.class == 'hunter'){
				    // LONG SLIM GUN
					ctx.fillStyle = "#d3d3d3";
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
	                
                    ctx.beginPath();
                    ctx.moveTo(0, -this.barrelWidth / 1.9 / 1.2); // top left
                    ctx.lineTo(this.barrelLength * 1.05, -this.barrelWidth /1.9 /1.2); // top right
                    ctx.lineTo(this.barrelLength * 1.05, this.barrelWidth/1.9 /1.2);  // bottom right
                    ctx.lineTo(0, this.barrelWidth/1.9);  // bottom left
                    ctx.closePath();
	                
                    ctx.fill();
                    ctx.stroke();
				    // BIG SHORT GUN
				    ctx.fillStyle = "#d3d3d3";
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
	                
                    ctx.beginPath();
                    ctx.moveTo(0, -this.barrelWidth/1.25); // top left
                    ctx.lineTo(this.barrelLength/1.1, -this.barrelWidth /1.25); // top right
                    ctx.lineTo(this.barrelLength/1.1, this.barrelWidth/1.25);  // bottom right
                    ctx.lineTo(0, this.barrelWidth/1.25);  // bottom left
                    ctx.closePath();
	                
                    ctx.fill();
                    ctx.stroke();
					
					
					
				}
                else if(this.class == 'trapper'){
				    // long trig
				     ctx.fillStyle = "#999999";
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2.5;
	                
                    ctx.beginPath();
                    ctx.moveTo(0, 0); // top left
                    ctx.lineTo(this.barrelLength/1.1, -this.barrelWidth); // top right
                    ctx.lineTo(this.barrelLength/1.1, this.barrelWidth);  // bottom right
                    ctx.lineTo(0, 0);  // bottom left
                    ctx.closePath();
                    ctx.fill();
					ctx.stroke();
					
					// big base rect
					ctx.fillStyle = "#999999";
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2.5;
	                
                    ctx.beginPath();
                    ctx.moveTo(0, -this.barrelWidth/1.2); // top left
                    ctx.lineTo(this.barrelLength/1.5, -this.barrelWidth/1.5); // top right
                    ctx.lineTo(this.barrelLength/1.5, this.barrelWidth/1.5);  // bottom right
                    ctx.lineTo(0, this.barrelWidth/1.2);  // bottom left
                    ctx.closePath();
	                
                    ctx.fill();
                    ctx.stroke();
				
				}
				ctx.restore()
				
				
				// Tank body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.stroke();
                   
				ctx.restore();
                
                // Health bar
				
                if (this.health < this.maxHealth) {
                    const barWidth = this.size * 2;
                    const barHeight = 6;
                    const barX = this.x - cameraX - barWidth/2;
                    const barY = this.y - cameraY - this.size - 15;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }

            }
        }

        class Bullet {
            constructor(x, y, angle, fromPlayer , of_class = 'tank', of_speed = 12 , of_damage = 9, of_pen = 10, of_size = 6) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = of_speed;
                this.size = of_size;
				this.class = of_class;
				this.life = 90;
				this.health = of_pen;
				this.damage = of_damage;
				this.slowness = 0;
				if(of_class == 'trapper'){
				    this.life = 1000;
					this.slowness = 0.3; // higher -->  slower
					this.speed = 20;
					this.health = 100;
					this.size = 12;
				}
	            if(of_class == 'sniper' || of_class == 'assasin'){
					this.life = 120;
					this.size = 9;
					this.speed = 15;
				}
				else if(of_class == 'twin' || of_class == 'machine_gun' || of_class == 'flank_guard' 
				|| of_class == 'tri_angle' || of_class == 'quad_tank' 
				|| of_class == "twin_flank" || of_class == 'auto_3' || of_class == 'tripleshot') {
					this.size = 9;
				}
				else if(of_class == 'destroyer'){
				    this.size = 20;
				}
				else if(of_class == 'gunner'){
				    this.size = 6;
				}
				else if(of_class == 'tank'){
				    this.size = 6;
				}
				else if(!(of_class == 'hunter' || of_class == 'trapper')){ // if not different bullets.
				    this.size = 6;
				}
				
				
                this.fromPlayer = fromPlayer;
                this.color = fromPlayer ? '#00b2e1' : '#f14e54';
            }
            
            update() {
			    this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
			    if(this.class == 'trapper'){
				    this.speed *= (1-this.slowness);
				}
				
                   
				
				
                this.life--;
                // Check collision with other bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const other = bullets[i];
                    if (other === this) continue; // don't compare with itself
                
                    // Optional: prevent friendly-fire bullet collision
                    if (this.fromPlayer === other.fromPlayer) continue;
                
                    const dist = Math.hypot(other.x - this.x, other.y - this.y);
                    if (dist < this.size + other.size) {
                        // Both bullets take damage from each other
                        if (this.takeDamage(other.damage)) {
						     particles.push(new Particle(other.x, other.y, other.color));
						     return false;
						}
                        if (other.takeDamage(this.damage)) {
						      bullets.splice(i, 1); // remove other bullet
							  particles.push(new Particle(this.x, this.y, this.color));
					    }
                    }
                }
                // Check collision with tanks
                const targets = this.fromPlayer ? enemies : (player ? [player] : []);
                for (let i = targets.length - 1; i >= 0; i--) {
                    const target = targets[i];
                    const dist = Math.hypot(target.x - this.x, target.y - this.y);
                    if (dist < target.size + this.size) {
					// collision
					const overlap = target.size + this.size - dist;
					const nx = (target.x-this.x)/ dist;
					const ny = (target.y-this.y) / dist;
					
					this.x -= nx * overlap * 0.75; // collision push factor 0.75
					this.y -= ny * overlap * 0.75;
					
					target.x += nx * overlap *0.75;
					target.y += ny * overlap * 0.75;
					
					// if destroyed
                       if (target.takeDamage(this.damage)) {
                           if (this.fromPlayer) {
                               addXP(target.isPlayer ? 100 : 50);
                               enemies.splice(i, 1);
                           }
						particles.push(new DeathEffect(target.x, target.y, this.angle, target.color));
                       }
                       if(this.takeDamage(target.body_damage)){ // if bullet got 0 health;
					    return false;
					}
                    }
                }
                
                // Check collision with shapes
                for (let i = shapes.length - 1; i >= 0; i--) {
                    const shape = shapes[i];
                    const dist = Math.hypot(shape.x - this.x, shape.y - this.y);
                    if (dist < shape.size + this.size) {
					// collision
					const overlap = shape.size + this.size - dist;
					const nx = (shape.x-this.x)/ dist;
					const ny = (shape.y-this.y) / dist;
					
					this.x -= nx * overlap * 0.9;
					this.y -= ny * overlap * 0.9;
					
					shape.x += nx * overlap *0.9;
					shape.y += ny * overlap * 0.9;
					// if destroyed
                        if (shape.takeDamage(this.damage)) {
                            if (this.fromPlayer) {
                                addXP(shape.xp);
                                
                            }
                            shapes.splice(i, 1);
							particles.push(new DeathEffect(shape.x, shape.y, this.angle, shape.color));
                        }
						if(this.takeDamage(shape.body_damage)){ // if bullet got 0 health;
						    return false;
						}
						
                        
                    }
                }
                
                return this.life > 0;
            }
            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x - cameraX, this.y - cameraY);
                ctx.rotate(this.angle);
	            
                if (this.class === 'trapper') {
                    // Draw a triangle-style trapper bullet
                    const size = this.size;
	            
                    ctx.beginPath();
                    ctx.moveTo(size, 0);
                    ctx.lineTo(-size * 0.6, size * 0.8);
                    ctx.lineTo(-size * 0.6, -size * 0.8);
                    ctx.closePath();
	            
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#444'; // outline color
                    ctx.stroke();
                } else {
                    // Default circular bullet
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#000';
                    ctx.stroke();
                }

    ctx.restore();
            }
        }

        class Shape {
            constructor(x, y, type = 'square') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = type === 'square' ? 15 : type === 'triangle' ? 20 : 35;
                this.health = type === 'square' ? 10 : type === 'triangle' ? 20 : 100;
				this.body_damage = type === 'square' ? 8 : type === 'triangle' ? 8 : 12;
                this.maxHealth = this.health;
                this.angle = 0;
                this.rotationSpeed = 0.02;
                this.color = type === 'square' ? '#ffe869' : type === 'triangle' ? '#fc7677' : '#768dfc';
                this.xp = type === 'square' ? 10 : type === 'triangle' ? 25 : 75;
            }
            
            update() {
                if(this.health <= 0) return false;
                this.angle += this.rotationSpeed;
			    for (const target of [...enemies , player]) {
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const minDist = this.size + target.size;
                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
	                
                        if (this.isPlayer) {
                            // Player gets pushed back
                            this.x -= nx * overlap;
                            this.y -= ny * overlap;
                        } else {
                            // Shape gets pushed
                            target.x += nx * overlap;
                            target.y += ny * overlap;
                        }
                    }
                }
				
            }
            
            takeDamage(damage) {
                this.health -= damage;
                
                // Create particles
                for (let i = 0; i < 3; i++) {
                    particles.push(new Particle(this.x, this.y, this.color));
                }
                
                return this.health <= 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - cameraX, this.y - cameraY);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                
                if (this.type === 'square') {
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    ctx.strokeRect(-this.size, -this.size, this.size * 2, this.size * 2);
                } else if (this.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(-this.size, this.size);
                    ctx.lineTo(this.size, this.size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5;
                        const x = Math.cos(angle) * this.size;
                        const y = Math.sin(angle) * this.size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                
                ctx.restore();
				
				// Health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.size * 2;
                    const barHeight = 6;
                    const barX = this.x - cameraX - barWidth/2;
                    const barY = this.y - cameraY - this.size - 15;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
            }
        }
        class DeathEffect {
            constructor(x, y, angle, color) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 2;
                this.alpha = 1;
                this.size = 20;
                this.color = color;
            }
	        
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.alpha -= 0.02;
                return this.alpha > 0;
            }
	        
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        class Particle {
            constructor(x, y, color, shape = 'circle', size = null) {
               this.x = x;
               this.y = y;
               this.vx = (Math.random() - 0.5) * 8;
               this.vy = (Math.random() - 0.5) * 8;
               this.size = size || Math.random() * 4 + 2;
               this.color = color;
               this.life = 30;
               this.maxLife = 30;
               this.shape = shape; // 'circle' or 'plus'
               this.rotation = Math.random() * Math.PI * 2;
               this.rotationSpeed = (Math.random() - 0.5) * 0.2;
           }
           
           update() {
               this.x += this.vx;
               this.y += this.vy;
               this.vx *= 0.98;
               this.vy *= 0.98;
               this.rotation += this.rotationSpeed;
               this.life--;
               return this.life > 0;
           }
           
           draw() {
               const alpha = this.life / this.maxLife;
               ctx.globalAlpha = alpha;
               ctx.fillStyle = this.color;
               
               const drawX = this.x - cameraX;
               const drawY = this.y - cameraY;
               
               if (this.shape === 'plus') {
                   ctx.save();
                   ctx.translate(drawX, drawY);
                   ctx.rotate(this.rotation);
                   
                   // Draw plus sign
                   const armLength = this.size * 1.5;
                   const armWidth = this.size / 2;
                   
                   // Horizontal arm
                   ctx.fillRect(-armLength, -armWidth, armLength * 2, armWidth * 2);
                   
                   // Vertical arm
                   ctx.fillRect(-armWidth, -armLength, armWidth * 2, armLength * 2);
                   
                   ctx.restore();
               } else {
                   // Default circle
                   ctx.beginPath();
                   ctx.arc(drawX, drawY, this.size, 0, Math.PI * 2);
                   ctx.fill();
               }
               
               ctx.globalAlpha = 1;
           }
        }

        function addXP(amount) {
            xp += amount * epsilon;
            while (xp >= xpToNext) {
                xp -= xpToNext;
                level++;
                //xpToNext = Math.floor(xpToNext * 1.5);
                skillPoints++;
                updateUI();
            }
			score += Math.floor(xp);
			epsilon *= epsilon_decay;
			if(epsilon < 1) epsilon = 1;
        }
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('levelText').textContent = `Level ${level}`;
            document.getElementById('levelFill').style.width = (xp / xpToNext) * 100 + '%';
            
            // Update upgrade buttons
            const upgradeBtns = document.querySelectorAll('.upgrade-btn');
            upgradeBtns.forEach(btn => {
                btn.disabled = skillPoints <= 0;
            });
        }
        function spawnShapes() {
            while (shapes.length < 100) {
                const x = Math.random() * 4000;
                const y = Math.random() * 4000;
                const rand = Math.random();
                const type = rand < 0.7 ? 'square' : rand < 0.9 ? 'triangle' : 'pentagon';
                shapes.push(new Shape(x, y, type));
            }
        }
        function spawnEnemies() {
            while (enemies.length < 12) {
                const x = Math.random() * 4000;
                const y = Math.random() * 4000;
                enemies.push(new Tank(x, y, false));
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#b7b7b7';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const startX = Math.floor(cameraX / gridSize) * gridSize;
            const startY = Math.floor(cameraY / gridSize) * gridSize;
            
            for (let x = startX; x < cameraX + canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - cameraX, 0);
                ctx.lineTo(x - cameraX, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < cameraY + canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - cameraY);
                ctx.lineTo(canvas.width, y - cameraY);
                ctx.stroke();
            }
        }
        function updateUpgradeButton(buttonId, value) {
           const button = document.getElementById(buttonId);
           button.querySelector('.upgrade-value').textContent = value;
           
           // Enable/disable based on skill points
           button.disabled = skillPoints <= 0;
           
           // Visual feedback when affordable
           if (skillPoints > 0) {
               button.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.5)';
           } else {
               button.style.boxShadow = 'none';
         }
}
        function gameLoop() {
            if (!gameRunning) return;
            if (isMouseDown && gameRunning && player) {
                player.shoot(player_class);
            }
			// update upgrades
			updateUpgradeButton('healthUpgrade', upgrades.health_reg);
            updateUpgradeButton('damageUpgrade', upgrades.damage);
            updateUpgradeButton('speedUpgrade', upgrades.speed);
            updateUpgradeButton('reloadUpgrade', upgrades.reload);
			updateUpgradeButton('bodydamageUpgrade', upgrades.body_damage);
			updateUpgradeButton('bulletspeedUpgrade', upgrades.bullet_speed);
			updateUpgradeButton('healthmaxUpgrade', upgrades.health);
			updateUpgradeButton('bulletpenUpgrade', upgrades.penetration);
			
			
            // Update camera
            if (player) {
                cameraX = player.x - canvas.width / 2;
                cameraY = player.y - canvas.height / 2;
            }
            
            // Update game objects
            if (player) player.update();
            
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (!bullets[i].update()) {
                    bullets.splice(i, 1);
                }
            }
            
            enemies.forEach(enemy => enemy.update());
            shapes.forEach(shape => shape.update());
            
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                }
            }
            
            // Spawn objects
            spawnShapes();
            spawnEnemies();
            
            // Draw everything
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            bullets.forEach(bullet => bullet.draw());
            shapes.forEach(shape => shape.draw());
            enemies.forEach(enemy => enemy.draw());
            if (player) player.draw();
            particles.forEach(particle => particle.draw());
            drawXCursor(mouseX  , mouseY );
            // Update UI
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'none';
            gameRunning = true;
            player = new Tank(2000, 2000, true);
            gameLoop();
        });
		document.getElementById('restartBtn').addEventListener('click', () => {
            window.location.reload();
        });

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
			
        });

        // Replace your click event with these three events
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0 && gameRunning && player) { // 0 = left mouse button
                isMouseDown = true;
                player.shoot(player_class); // Immediate shot on click
            }
        });
		
		// For auto-3. already defined mouseX,Y but i want this too, non normalised.
        canvas.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isMouseDown = false;
            }
        });
        
        // Optional: Stop shooting if mouse leaves canvas
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
    
        // Upgrade buttons
        document.getElementById('healthUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.health_reg++;
                skillPoints--;
            }
        });
        document.getElementById('damageUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.damage++;
                skillPoints--;
            }
        });
        document.getElementById('speedUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.speed++;
                skillPoints--;
            }
        });
        document.getElementById('reloadUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.reload++;
                skillPoints--;
            }
        });
		document.getElementById('bodydamageUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.body_damage++;
                skillPoints--;
            }
        });
		document.getElementById('bulletspeedUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.bullet_speed++;
                skillPoints--;
            }
        });
		document.getElementById('healthmaxUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.health++;
                skillPoints--;
            }
        });
		document.getElementById('bulletpenUpgrade').addEventListener('click', () => {
            if (skillPoints > 0) {
                upgrades.penetration++;
                skillPoints--;
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>